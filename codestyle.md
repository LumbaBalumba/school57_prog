# Руководство по стилю кода Python в соответствии с PEP8

## 1. Оформление кода
### 1.1 Отступы
- **Используйте 4 пробела на уровень отступа**:
	- Не используйте табуляцию или смешение табуляции с пробелами.
	- Настройте текстовый редактор так, чтобы при нажатии клавиши табуляции вставлялись 4 пробела.
### 1.2 Максимальная длина строки
- **Ограничьте все строки максимальной длиной в 79 символов**:
	- Для блоков текста (например, docstring или комментариев) ограничьте строки 72 символами.
	- Используйте обратные косые черты или скобки для переноса длинных строк.
### 1.3 Пустые строки
- **Разделяйте определения функций и классов верхнего уровня двумя пустыми строками**.
- **Определения методов внутри класса должны быть разделены одной пустой строкой**.
- **Обрамляйте код верхнего уровня в функции или классе двумя пустыми строками**.
### 1.4 Импорты
- **Импорты, как правило, должны быть на отдельных строках**:
  ```python
  # Правильно:
  import os
  import sys

  # Неправильно:
  import sys, os
  ```
- **Инструкции импорта должны располагаться в начале файла, сразу после любых комментариев модуля и docstring**.
- **Импорты должны быть сгруппированы в следующем порядке**:
	  1. Импорты стандартной библиотеки.
	  2. Импорты сторонних библиотек.
	  3. Импорты, специфичные для приложения/библиотеки.
	  - **Пример**:
    ```python
    import os
    import sys

    import requests

    from mymodule import myfunction
    ```
### 1.5 Пробелы в выражениях и операторах
- **Избегайте лишних пробелов в следующих случаях**:
	- Внутри круглых, квадратных скобок или фигурных скобок.
	- Между запятой и закрывающей скобкой.
	- Перед запятой, точкой с запятой или двоеточием.
  - **Правильно**:
    ```python
    spam(ham[1], {eggs: 2})
    ```
  - **Неправильно**:
    ```python
    spam( ham[ 1 ], { eggs: 2 } )
    ```
- **Всегда окружайте бинарные операторы пробелами с обеих сторон** (например, оператор присваивания (`=`), операторы сравнения (`==`), арифметические операторы и т.д.).
  - **Правильно**:
    ```python
    x = y + z
    ```
  - **Неправильно**:
    ```python
    x=y+z
    ```
## 2 Аннотация переменных
### 2.1 Простейшие случаи
- **Аннотация должна содержит непосредственно ожидаемый тип переменной**.
- **Аннотации для переменных пишут через двоеточие после идентификатора**.
  ```python
  price: int = 57
  title: str = 'Картошка'
  ```
- **Если вы не хотите ограничивать возможные типы переменной, то используйте `Any` из модуля [`typing`](https://docs.python.org/3/library/typing.html)**.
  ```python
  from typing import Any
  
  
  unknown_item: Any = 57
  unknown_item = 'Картошка'
  ```
- **Если вы хотите ограничить типы переменных до нескольких типов, то используйте `Union` из модуля [`typing`](https://docs.python.org/3/library/typing.html) и пропишите в квадратных скобках все возможные типы**.
  ```python
  from typing import Union
  
  
  unknown_number: Union[int, float] = 57
  unknown_item = 5.7
  ```
### 2.2 Аннотации параметров функции
- **Параметры функции аннотируются так же как переменные, а возвращаемое значение указывается после стрелки `->` и до завершающего двоеточия**. 
  ```python
  def indent_right(some_string: str, width: int) -> str:
      return " " * (max(0, width - len(some_string))) + some_string
  ```
- **Если функция ничего не возвращает, то мы считаем, что возвращается `None`** (есть еще случаи с `NoReturn`, но это только когда функция никогда не заканчивает выполнение / всегда выбрасывает исключение).
  ```python
  def write_to_file(file_name: str, text: str) -> None:
      with open(file_name, w, encoding='utf-8') as some_file:
          some_file.write(text)
  ```
- **Если это генераторная функция, то есть её тело содержит оператор `yield`, для возвращаемого можно воспользоваться аннотацией `Iterable[...]`**.
  ```python
  from typing import Iterable
  
  
  def generate_two() -> Iterable[int]:
      yield 2
  ```
### 2.3 Коллекции
- **При аннотации коллекций (списки, кортежи, словари, множества) надо прописать также их тип**.
	- Если вы используете Python 3.9+, то типы переменных остаются, например `list`, `tuple`, `dict`, `set`. 
	- Если ваша версия ниже, то импортируйте `List`, `Tuple`, `Dict`, `Set` из модуля [`typing`](https://docs.python.org/3/library/typing.html) соответственно.
- **Помимо аннотации самой коллекции, надо также прописать в квадратных скобках типы объектов внутри**.
  ```python
  # Python 3.9+
  titles: list[str] = ["hello", "world"]
  
  price_container: tuple[int] = (1, 2)
  
  book_authors: dict[str, str] = {"Fahrenheit 451": "Bradbury"}
  book_price: dict[str, float] = {"Fahrenheit 451": 239.9, "1984": 575.7}
  ```

  ```python
  # Python 3.8-
  from typing import List, Tuple, Dict
  
  
  titles: List[str] = ["hello", "world"]
  
  price_container: Tuple[int] = (1, 2)
  
  book_authors: Dict[str, str] = {"Fahrenheit 451": "Bradbury"}
  book_price: Dict[str, float] = {"Fahrenheit 451": 239.9, "1984": 575.7}
  ```
## 3. Комментарии
### 3.1 Блочные комментарии
- **Блочные комментарии, как правило, относятся к коду, следующему за ними, и имеют тот же уровень отступа, что и код**.
- **Каждая строка блочного комментария начинается с `#` и одного пробела** (если это не отступленный текст внутри комментария).
### 3.2 Встроенные комментарии
- **Используйте встроенные комментарии экономно**.
- **Встроенный комментарий — это комментарий на той же строке, что и инструкция**.
- **Отделяйте встроенные комментарии от инструкции как минимум двумя пробелами**:
  ```python
  x = x + 1  # Увеличить x на 1
  ```
### 3.3 Строки документации (Docstrings)
- **Пишите строки документации для всех публичных модулей, функций, классов и методов**.
- **Docstrings должны описывать действие метода, а также все аргументы и возвращаемые значения**.
  ```python
  def multiply(a: int, b: int) -> int:
      """Умножает два числа и возвращает результат.
  
      Аргументы:
          a (int): Первое число.
          b (int): Второе число.
  
      Возвращает:
          int: Результат умножения a и b.
      """
      return a * b
  ```
- **Если у метода нет аргументов или он ничего не возвращает, то этот кусок описания можно опустить**.
## 4. Соглашения по наименованию
### 4.1 Имена переменных
- **Используйте `snake_case` для имен переменных и функций**.
  ```python
  my_variable = 10
  def my_function():
      pass
  ```
### 4.2 Имена функций и переменных
- **Имена функций должны быть в нижнем регистре, слова разделяются подчеркиванием** для улучшения читаемости.
### 4.3 Имена классов
- **Используйте `CamelCase` для имен классов**:
  ```python
  class MyClass:
  	pass
  ```
### 4.4 Константы
- **Константы должны объявляться на уровне модуля и записываться в `UPPERCASE_WITH_UNDERSCORES`**.
  ```python
  MAX_CONNECTIONS = 100
  ```
## 5. Рекомендации по программированию
### 5.1 Избегайте прямого сравнения с `True`, `False` или `None`
- **Всегда используйте `if foo is None:`, а не `if foo == None:`**.
- **Для булевых значений используйте контекстное сравнение**:
  ```python
  if not x:  # Правильно
  if x is False:  # Неправильно
  ```
### 5.2 Обработка исключений
- **Используйте исключения в ситуациях, когда программа должна вести себя иначе, чем обычно**:
  - Предпочитайте использование блоков `try/except`, а не явную проверку на наличие исключения.
    ```python
    try:
        value = my_list[index]
    except IndexError:
        handle_exception()
    ```
## 6. Организация кода
### 6.1 Структура модуля
- **Следуйте этому порядку при организации содержимого модуля**:
  1. Docstring модуля.
  2. Импорты на уровне модуля.
  3. Константы и глобальные переменные.
  4. Классы и функции.
### 6.2 Основная функция
- **При написании скрипта включите основную функцию и защитите точку входа с помощью `if __name__ == "__main__":`**.
  ```python
  def main():
      pass
  
  if __name__ == "__main__":
      main()
  ```
